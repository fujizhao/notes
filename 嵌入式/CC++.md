## 2.1 c和c++区别、概念相关面试题

[toc]

**2.1 c和c++区别、概念相关面试题**

**2.1.1 new和malloc的区别⭐⭐⭐⭐⭐**

**2.1.2 malloc的底层实现⭐⭐⭐⭐**

**2.1.3在1G内存的计算机中能否malloc(1.2G)？为什么？⭐⭐**

**2.1.4指针与引用的相同和区别；如何相互转换？⭐⭐⭐⭐⭐**

**2.1.5 C语言检索内存情况 内存分配的方式⭐⭐⭐**

*2.1.6  extern”C” 的作用⭐⭐⭐*

*2.1.7头文件声明时加extern定义时不要加 因为extern可以多次声明，但只有一个定义⭐⭐⭐⭐*

*2.1.8函数参数压栈顺序，即关于__stdcall和__cdecl调用方式的理解⭐⭐⭐*

*2.1.9重写memcpy()函数需要注意哪些问题⭐⭐*

*2.1.10数组到底存放在哪里⭐⭐⭐*



*2.1.11  struct和class的区别 ⭐⭐⭐⭐⭐*

*2.1.12 char和int之间的转换；⭐⭐⭐*

*2.1.13  static的用法（定义和用途）⭐⭐⭐⭐⭐*

*2.1.14  cosnt的用法（定义和用途）⭐⭐⭐⭐⭐*

*2.1.15const常量和#define的区别（编译阶段、安全性、内存占用等） ⭐⭐⭐⭐*

*2.1.16  volatile作用和用法 ⭐⭐⭐⭐⭐*

*2.1.17有常量指针 指针常量 常量引用 没有 引用常量⭐⭐⭐*

*2.1.18没有指向引用的指针，因为引用是没有地址的，但是有指针的引用⭐⭐⭐*

*2.1.19c/c++中变量的作用域⭐⭐⭐⭐⭐*

*2.1.20 c++中类型转换机制？各适用什么环境？dynamic_cast转换失败时，会出现什么情况？⭐⭐⭐*



## 2.2 继承、多态相关面试题 ⭐⭐⭐⭐⭐

*2.2.1继承和虚继承 ⭐⭐⭐⭐⭐*

*2.2.2多态的类，内存布局是怎么样的 ⭐⭐⭐⭐⭐*

*2.2.3被隐藏的基类函数如何调用或者子类调用父类的同名函数和父类成员变量 ⭐⭐⭐⭐⭐*

*2.2.4多态实现的三个条件、实现的原理 ⭐⭐⭐⭐⭐*

*2.2.5对拷贝构造函数 深浅拷贝 的理解 拷贝构造函数作用及用途？什么时候需要自定义拷贝构造函数？⭐⭐⭐*

*2.2.6析构函数可以抛出异常吗？为什么不能抛出异常？除了资源泄露，还有其他需考虑的因素吗？⭐⭐⭐*

*2.2.7什么情况下会调用拷贝构造函数（三种情况）⭐⭐⭐*

*2.2.8析构函数一般写成虚函数的原因⭐⭐⭐⭐⭐*

*2.2.9构造函数为什么一般不定义为虚函数⭐⭐⭐⭐⭐*

*2.2.10什么是纯虚函数⭐⭐⭐⭐⭐*

*2.2.11静态绑定和动态绑定的介绍⭐⭐⭐⭐*

*2.2.12 C++所有的构造函数 ⭐⭐⭐*

*2.2.13重写、重载、覆盖的区别⭐⭐⭐⭐⭐*

*2.2.14成员初始化列表的概念，为什么用成员初始化列表会快一些（性能优势）？⭐⭐⭐⭐* 

*2.2.15如何避免编译器进行的隐式类型转换；（explicit）⭐⭐⭐⭐*

## 2.1.1 new和malloc的区别⭐⭐⭐⭐⭐



**解析：这个题目是我多次面试时被问到的最高频问题之一，建议各位童鞋必须弄懂。**

**答：**

1）new、delete是C++中独有的操作符，而malloc和free是C/C++中的标准库函数。

2）使用new创建对象在分配内存的时候会自动调用构造函数，同时也可以完成对对象的初始化，同理要记得delete也能自动调用析构函数。因为malloc和 free是库函数而不是运算符，不在编译器控制范围之内，所以不能够自动调用构造函数和析构函数。也就是mallloc只是单纯地为变量分配内存，free也只是释放变量的内存。

3）new返回的是指定类型的指针，并且可以自动计算所申请内存的大小。而malloc返回的是void*类型，我们需要强行将其转换为实际类型的指针，并且需要指定好要申请内存的大小，malloc不会自动计算的。

4）C++允许重载new/delete操作符，而malloc和free是一个函数，并不能重载。

5）new内存分配失败时，会抛出bad_alloc异常。malloc分配内存失败时返回NULL。

6）内存区域：先了解自由存储区和堆，两者不相等于的。自由存储区是C++基于new操作符的一个抽象概念，凡是通过new操作符进行内存申请，该内存即为自由存储区。堆是操作系统中的术语，是操作系统所维护的一块特殊内存，用于程序的内存动态分配。new操作符从自由存储区上为对象动态分配内存空间，而malloc函数从堆上动态分配内存。





## 2.1.2 malloc的底层实现⭐⭐⭐⭐

**感谢**：感谢牛友“杰兮”反馈，要更加深刻的了解C++内存管理，可参考侯捷老师的《C++内存管理》，侯捷老师就不用多说了，多本著作翻译者，《effective C++》《more effective C++》等，著有《STL源码剖析》，巨佬。以下解析是我在网上所查阅整理的。

**解析**：回顾进程的空间模型，如图2-1所示，



![img](Untitled.assets/545613072_1585807530046_BA790DD96ECB01631BE6C7F06C787264)

图2-1进程空间示意图

   与1.1.5节的图相比，多了一个program break指针，Linux维护一个break指针，这个指针指向堆空间的某个地址。从堆起始地址到break之间的地址空间为映射好的，可以供进程访问；而从break往上，是未映射的地址空间，如果访问这段空间则程序会报错。我们用malloc进行内存分配就是从break往上进行的。



![img](Untitled.assets/545613072_1585807559818_BE8AEA4E2F3DD9DB2805F2BAE116A4A7)

图2-2堆内部机制

获取了break地址，也就是内存申请的初始地址，下面是malloc的整体实现方案：

malloc函数的实质是它有一个将可用的内存块连接为一个长长的列表的所谓空闲链表。 调用malloc（）函数时，它沿着连接表寻找一个大到足以满足用户请求所需要的内存块。 然后，将该内存块一分为二（一块的大小与用户申请的大小相等，另一块的大小就是剩下来的字节）。 接下来，将分配给用户的那块内存存储区域传给用户，并将剩下的那块（如果有的话）返回到连接表上。 调用free函数时，它将用户释放的内存块连接到空闲链表上。 到最后，空闲链会被切成很多的小内存片段，如果这时用户申请一个大的内存片段， 那么空闲链表上可能没有可以满足用户要求的片段了。于是，malloc（）函数请求延时，并开始在空闲链表上检查各内存片段，对它们进行内存整理，将相邻的小空闲块合并成较大的内存块。

## 2.1.3在1G内存的计算机中能否malloc(1.2G)？为什么？⭐⭐

**答：**是有可能申请1.2G的内存的。

**解析：**回答这个问题前需要知道malloc的作用和原理，应用程序通过malloc函数可以向程序的虚拟空间申请一块**虚拟地址空间**，与物理内存没有直接关系，得到的是在虚拟地址空间中的地址，之后程序运行所提供的物理内存是由操作系统完成的。

  我们要申请空间的大小为1.2G=2 30 × 1.2 Byte ，转换为十六进制约为 4CCC CCCC ，这个数值还在 unsigned int 的表示范围。 malloc 函数要求的参数正是unsigned int。在当前正在使用的Windows环境中，可申请的最大空间超过1.9G。实际上，具体的数值会受到操作系统版本、程序本身的大小、用到的动态/共享库数量、大小、程序栈数量、大小等的影响，甚至每次运行的结果都可能存在差异，因为有些操作系统使用了一种叫做随机地址分布的技术，使得进程的堆空间变小。感兴趣的读者可以去研究操作系统中的相关内容。

  综上，是有可能通过malloc( size_t ) 函数调用申请超过该机器物理内存大小的内存块的。

## 2.1.4指针与引用的相同和区别；如何相互转换？⭐⭐⭐⭐⭐



***\*感谢：感谢寞明牛友反馈区别6，现已加上解释，面试的时候能把这8个区别说出来，面试官会给你加分。\****

​      ***\*感谢牛友201903190906813指\*******\*出区别8的错误，现在已将区别8划入“相同”，引用也是占内存的。\****

***\*解析：指针与引用这个考点是重中之重，超级经典面试题之一。务必能说出来。\****

***\*相同：\**都是地址的概念；**

指针指向一块内存，它的内容是所指内存的地址；引用是某块内存的别名。

从内存分配上看：**两者都是占内存的**，程序为指针变量分配内存区域，在32位系统指针变量一般占用4字节内存，而引用本质是指针常量，所指向的对象不能改变，但指向的对象的值可以改变，引用和指针一样是地址概念，所以本身都是会占用内存的（有的编译器优化后就不占用内存了）。不过也略有区别，见下面的区别7.

***\*区别：\****

1.  指针是一个实体，而引用仅是个别名

2.  指针和引用的自增(++)运算意义不一样，指针是对内存地址的自增，引用是对值的自增；

量或对象的地址)的大小；

3.  引用使用时无需解引用(*)，指针需要解引用；

4.  引用只能在定义时被初始化一次，之后不可变；指针可变；

5.  引用不能为空，指针可以为空；

6.	.引用没有const，指针有const；（本人当初看到这句话表示疑问，这里解释一下：指针有“指针常量”即int * const a,但是引用没有int& const a，不过引用有“常引用”即const int &a = 1）

7. “sizeof 引用”得到的是所指向的变量(对象)的大小，而“sizeof 指针”得到的是指针本身的大小，在32位系统指针变量一般占用4字节内存。



***\*指针和引用之间怎么转换\**\**：\****

1）指针转引用：把指针用*就可以转换成对象，可以用在引用参数当中。

2）引用转指针：把引用类型的对象用&取地址就获得指针了。



```
int` `a = 0;` `int` `*pA = &a;` `void` `fun(``int` `&va){}
```

此时调用: fun(*pA);

pA是指针，加个*号后可以转换成该指针指向的对象，此时fun的形参是一个引用值，pA指针指向的对象会转换成引用va。

## 2.1.5 C语言检索内存情况 内存分配的方式⭐⭐⭐

**解析：**检索内存：顾名思义，对某段内存进行遍历搜索。

内存分配：

1、从静态存储区域分配。内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。例如全局变量，static变量。

2、在栈上创建。在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。

3、从堆上分配，亦称动态内存分配。程序在运行的时候用malloc或new申请任意多少的内存，程序员自己负责在何时用free或delete释放内存。动态内存的生存期由程序员决定，使用非常灵活，但如果在堆上分配了空间，就有责任回收它，否则运行的程序会出现内存泄漏，频繁地分配和释放不同大小的堆空间将会产生堆内碎块。

## 2.1.6  extern”C” 的作用

**解析：**

我们可以在C++中使用C的已编译好的函数模块，这时候就需要用到extern”C”。这是为了避免C++ name mangling，主要用于动态链接库，使得在C++里导出函数名称与C语言规则一致（不改变），方便不同的编译器甚至是不同的开发语言调用。

那么我们来看看C++语言规则和C语言规则有何不同。如果我们定义一个函数：

int fun(int a)；

如果是C++编译器，则可能将此函数改名为int_fun_int,（C++重载机制就这么来的）。如果有加上extern”C修饰，则c++编译器会按照C语言编译器一样编译为_fun。

 

**答：**extern”C”的作用在于C++代码中调用的C函数的声明，或C++中编译的函数要在C中调用。

**注意**：

1）C++调用一个C语言编写的.so库时，包含描述.so库中函数的头文件时，应该将对应的头文件放置在extern “C”{}格式的{}中，。

2）C中引用C++中的全局函数时，C++的头文件需要加extern “C”，而C文件中不能用extern “C”，只能使用extern关键字。

3）**也就是extern“C” 都是在c++文件里添加的！**

## 2.1.7 extern容易忽略的知识点

答：

1）头文件声明时加extern定义时不要加，因为extern可以多次声明，但只有一个定义。

2）extern在链接阶段起作用（四大阶段：预处理--编译--汇编--链接）。

## 2.1.8 函数参数压栈顺序，即关于__stdcall和__cdecl调用方式的理解

**解析：**

__stdcall和__cdecl都是函数调用约定关键字，我们先来看看__stdcall和__cdecl调用方式的概念：

**1）****__stdcall**：是StandardCall的缩写，是C++的标准调用方式，参数由右向左压入堆栈，由调用者负责把参数压入栈，最后由被调用者负责清除栈的内容。

**2）****__cdecl：**是C Declaration的缩写（declaration，声明），表示C语言默认的函数调用方法：参数也是由右向左压入堆栈；由调用者负责把参数压入栈，最后也由调用者负责清除栈的内容。

总结：因为以上2点，_cdecl这种调用约定的特点是支持可变数量的参数，比如printf方法，__stdcall不支持可变数量的参数。

假设函数fun（）作为调用者调用printf打印东西时，可以输入不同数量的参数，printf作为被调用者，并不知道调用者fun（）到底将多少参数压入堆栈，因此printf就没有办法自己清理堆栈，所以只有函数退出之后，由fun清理堆栈，因为fun总是知道自己传入了多少参数。

 

## 2.1.9 重写memcpy()函数需要注意哪些问题？

答：自己动手实现memcpy()时就需要考虑地址重叠的情况。我们来看个简单的例子。有一个5个元素的数组，不妨设为int arr = {1,2,3,4,5};考虑2种情况：

1）源地址是arr[2]，目标地址是arr[0],自前向后拷贝3个元素后arr为{3,4,5,4,5}

2）源地址是arr[0]，目标地址是arr[2],自前向后拷贝3个元素后arr为{1,2,1,2,3}

第一种情况，由低地址向高地址逐个将源地址的元素拷贝到目标地址就行，容易；

第二种情况需要注意，如果是按第一种情况由低地址拷贝到高地址，需要分3个步骤把arr[0]=1,arr[1]=2,arr[2]=3三个元素逐个拷贝，重点在于第一步是将arr[0]拷贝到arr[2]的位置，这样就会把原来的arr[2]=3改为arr[2]=1，覆盖了原来的值，因此在这种情况，我们需要自后向前拷贝，也就是高地址向低地址拷贝。也就是第一步将arr[2]放到arr[4],第二步将arr[1]放到arr[3],第一步将arr[0]放到arr[2].

看一下代码：

感谢：牛友“牛客513303394号”指出以下代码多了一个标点符号，互勉。

```cpp
void *Memcpy(void *dst, const void *src, size_t1 size)
 
{
 
    char *psrc;  //源地址
    char *pdst;  //目标地址
  
    if(NULL == dst || NULL == src)
    {
        return NULL;
    }
 
    if((src < dst) && (char *)src + size > (char *)dst)  //源地址在前，对应上述情况2，需要自后//向前拷贝
    {
        psrc = (char *)src + size - 1;
        pdst = (char *)dst + size - 1;
        while(size--)
        {
            *pdst-- = *psrc--;
        }
    }
    else   //源地址在后，对应上述第一种情况，直接逐个拷贝*pdst++ = *psrc++即可
    {
        psrc = (char *)src;
        pdst = (char *)dst;
        while(size--)
        {
            *pdst++ = *psrc++;
        }
    }
    return dst;
 
}
```





## 2.1.10数组到底存放在哪里

**解析：**

1、固定数组在函数体内分配（不带static）是在栈中的

2、固定数组是全局变量和带static前缀的局部数组是在全局数据的

3、固定数组在类中分配是在堆中的

4、动态数组（通过malloc或者new出来的空间）不管在函数体中、类中、全局变量都是在堆中

## 2.1.11  struct和class的区别

**解析**：首先要知道C++是完全兼容C语言的，因此大家可能会随着学习的深入觉得C++中的struct并没有必要保存，因为struct可以完成的事情，class都可以完成。甚至在C++中struct也可以有构造函数，析构函数，结构体之间也可以继承等等。也就是C++中的struct和class其实意义一样。

**总结**：C++中存在struct的唯一意义就是为了让C语言程序员有归属感，是为了让C++编译器兼容以前用C语言开发的项目。

**答**：两者最大区别是struct里面默认的访问控制是public，而class中的默认访问控制是private。

## 2.1.12 char和int之间的转换；

**解析：**

1）首先char与int都分为signed与unsigned类型，默认情况下都是signed类型。

2）从长字节数据类型转换为短字节数据类型，会产生截断：

如从4字节的int类型转换成1个字节的char类型，则取int数据的最低的一个字节，将这个字节的数据赋给char型数据，且是有符号的，即首位为符号位；而如果是从int转换成unsigned char类型，则整个一个字节都是数据，没有符号位。

1）从短字节类型转换为长字节类型，从char转换为int：则在前面的三个字节补符号位，即补上0xffffff（char的首位为1），或0x000000（char的首位为0）。从unsigned char转换为int，则前面补上0x000000.

## 2.1.13  static的用法（定义和用途）

解析：

在C语言中，static作用：“改变生命周期” 或者 “改变作用域”。有以下特性：

1）static局部变量：局部变量为动态存储，即指令执行到定义处才分配内存，将一个变量声明为函数的局部变量，使其变为静态存储方式(静态数据区)，那么这个局部变量在函数执行完成之后不会被释放，而是继续保留在内存中。

2）static全局变量：全局变量即定义{}外面，其本身就是静态变量，编译时就分配内存，这只会改变其连接方式，使其只在本文件内部有效，而其他文件不可连接或引用该变量。

3）static函数：对函数的连接方式产生影响，使得函数只在本文件内部有效，对其他文件是不可见的。这样的函数又叫作静态函数。使用静态函数的好处是，不用担心与其他文件的同名函数产生干扰，另外也是对函数本身的一种保护机制。如果想要其他文件可以引用本地函数，则要在函数定义时使用关键字extern，表示该函数是外部函数，可供其他文件调用。另外在要引用别的文件中定义的外部函数的文件中，使用extern声明要用的外部函数即可。

到了C++的时候，static多了几个其他的作用：

4）static类成员变量：表示这个成员为全类所共有，对类的所有对象只有一份拷贝，可以借助类名直接访问。

5）static类成员函数：表示这个函数为全类所共有，而且只能访问静态成员变量，因为这个函数不接收this指针。

 

## 2.1.14  const的用法（定义和用途）

Const就是常量修饰符，const变量应该在声明的时候就进行初始化，如果在声明常量的适合没有提供值，则该常量的值是不确定的，且无法修改。

const修饰主要用来修饰变量、函数形参和类成员函数：

1）const常量：定义时就初始化，以后不能更改。

2）const形参：func(const int a){};该形参在函数里不能改变

3）const修饰类成员函数：该函数对成员变量只能进行只读操作，就是const类成员函数是不能修改成员变量的数值的。

 

## 2.1.15 const常量和#define的区别（编译阶段、安全性、内存占用等）

**解析**：主要有以下区别

1）用#define MAX 255定义的常量是**没有类型**的（不进行类型安全检查，可能会产生意想不到的错误），所给出的是一个立即数，编译器只是把所定义的常量值与所定义的常量的名字联系起来，define所定义的宏变量在**预处理****阶段**的时候进行替换，在程序中使用到该常量的地方都要进行拷贝替换；

用const float MAX = 255;定义的常量**有类型**（**编译时会进行类型检查）名字，存放在内存的静态区域中，在**编译时**确定其值。在程序运行过程中const变量只有**一个拷贝**，而#define所定义的宏变量却有多个拷贝，所以宏定义在程序运行过程中所消耗的**内存**要比const变量的大得多；

2）用define定义的常量是不可以用指针变量去指向的，用const定义的常量是可以用指针去指向该常量的地址的；

3）用define可以定义一些简单的函数（宏替换只作替换，不做计算，不做表达式求解），const是不可以定义函数的.

4）宏定义的作用范围仅限于当前文件。 而默认状态下，const对象只在文件内有效，当多个文件中出现了同名的const变量时，等同于在不同文件中分别定义了独立的变量。 如果想在多个文件之间共享const对象，必须在变量定义之前添加extern关键字（在声明和定义时都要加）。

## 2.1.16  volatile作用和用法

解析：.volatile的本意是“易变的” 因为访问寄存器要比访问内存单元快的多,所以编译器一般都会作减少存取内存的优化，但有可能会读脏数据。当要求使用volatile声明变量值的时候，编译器对访问该变量的代码就不再进行优化，系统总是重新从它所在的内存读取数据，即使它前面的指令刚刚从该处读取过数据。

答：volatile关键词的作用是影响编译器编译的结果，用volatile声明的变量表示该变量随时可能发生变化，与该变量有关的运算，不要进行编译优化，以免出错。

案例：我们来看看以下几个使用volatile的案例：

（1）中断服务程序中修改的供其它程序检测的变量需要加volatile；

```cpp
int i=0;
 
int main(void)
 
{
     ...
     while (1){
        if (i) dosomething();
     }
｝
 
/* Interrupt service routine. */
void ISR_2(void)
{
      i=1;
}
```

程序的本意是希望ISR_2中断产生时，在main函数中调用dosomething函数，但是，由于编译器判断在main函数里面没有修改过i，因此可能只执行一次对从i到某寄存器的读操作，然后每次if判断都只使用这个寄存器里面的“i副本”，导致dosomething永远也不会被调用。如果将变量加上volatile修饰，则编译器保证对此变量的读写操作都不会被优化（肯定执行）。此例中i也应该是volatile int i；

（2）多任务环境下（如多线程）各任务间共享的标志应该加volatile；

（3）存储器映射的硬件寄存器通常也要加voliate，因为每次对它的读写都可能有不同意义。

例如：假设要对一个设备进行初始化，此设备的某一个寄存器为0xff800000。

```cpp
int  *output = (unsigned  int *)0xff800000;//定义一个IO端口；
int   init(void)
{
      int i;
      for(i=0;i< 10;i++){
         *output = i;
}
}
```

经过编译器优化后，编译器认为前面循环半天都是废话，对最后的结果毫无影响，因为最终只是将output这个指针赋值为9，所以编译器最后给你编译编译的代码结果相当于：

```cpp
int  init(void)
{
      *output = 9;
}
```

如果你对此外部设备进行初始化的过程是必须是像上面代码一样顺序的对其赋值，显然优化过程并不能达到目的。反之如果你不是对此端口反复写操作，而是反复读操作，其结果是一样的，编译器在优化后，也许你的代码对此地址的读操作只做了一次。然而从代码角度看是没有任何问题的。这时候就该使用volatile通知编译器这个变量是一个不稳定的，在遇到此变量时候不要优化。

例如：

```cpp
volatile  int *output=(volatile unsigned int *)0xff800000;//定义一个I/O端口
```

## 2.1.17有常量指针 指针常量 常量引用 没有 引用常量

解析：这几个概念面试官偶尔会调皮的问一下，所以还是要区分好几个概念，不要混淆，以上4个概念都可以从最后两个字开始记起，后面两个字代表这是个什么东东，前面两个字代表这个是什么类型：

（1）常量指针：也叫常指针，最后两个字是“指针”，代表这是一个指针，但指向的是一个常量，如下：

```cpp
int a = 0;
const int *p = &a; //不可以通过p改变a
```

（2）指针常量：后面两个字是“常量”，代表这是个常量，不过是指针类型的常量，

```cpp
int a = 0;
int *const p = &a; //从后往前看，这是个指针常量，指向的a的值可以改变，但p本身不可改变
```

注意：如果从代码来区分常量指针指针常量，那么可以从后往前看const的位置，

```cpp
const int *p = &a //从后往前看，const修饰的是*p，所以指针p指向的数值不可变
int *const p = &a; //从后往前看，const修饰的是p，所以指针p本身不可变
```

（3）常量引用：后两个字是“引用”，那么这个是引用，并且是常量的引用，那么就有两个性质，如下：

```cpp
double a;
const int &r = a; //正确 性质1：不可通过常量引用r来改变a
const int &r = 10;//正确 性质2：常量引用可以直接引用具体数值
```

（4）没有引用常量：后面两个字代表这个是常量，前面代表这个是引用类型的常量，然而常量就是常量了，并没有引用类型的常量。

## 2.1.18没有指向引用的指针，但是有指针的引用

解析：如何理解这句话呢，首先，没有指向引用的指针，因为指针是本质上是指向某一块内存空间的，而引用只是一个变量的别名，本身是没有地址的，如果要创建一个指针指向某个引用，那么其实指向的是这个引用所引用的对象，看下面代码：

```cpp
int v = 1;
int &ri = v; //整型变量v的引用
int *p = &ri; //指针p其实指向的是变量v
```

其次，有指针的引用，我们直接看代码：

```cpp
int v = 1;
int *p = &v;
int *&rp = p;
```

第一个是要理解int *&rp = p; 这是定义了一个变量rp，还是从后往前看，距离rp左边最近的修饰符决定rp是个什么东东，剩下的就是rp的具体值。因此我们发现距离rp左边最近的是&，代表rp是个引用，所以int *&rp = p; 可以看作int *（&rp ）= p; 如果我们把（&rp）当作一个整体，又可以看作int * RP = p；到此为止，我们就可以很明显的知道这句话其实就是定义了一个引用rp指向指针p。

## 2.1.19 c/c++中变量的作用域

解析：作用域规则告诉我们一个变量的有效范围，它在哪儿创建，在哪儿销毁。变量的有效作用域从它的定义点开始，到和定义变量之前最邻近的开括号配对的第一个闭括号。也就是说，作用域由变量所在的最近一对括号确定。

答：

(1)全局变量：

  全局变量是在所有函数体的外部定义的，程序的所在部分（甚至其它文件中的代码）都可以使用。全局变量不受作用域的影响（也就是说，全局变量的生命期一直到程序的结束）。如果在一个文件中使用extern关键字来声明另一个文件中存在的全局变量，那么这个文件可以使用这个数据。

(2)局部变量：

  局部变量出现在一个作用域内，它们是局限于一个函数的。局部变量经常被称为自动变量，因为它们在进入作用域时自动生成，离开作用域时自动消失。关键字auto可以显式地说明这个问题，但是局部变量默认为auto，所以没有必要声明为auto。

(3)寄存器变量

  寄存器变量是一种局部变量。关键字register告诉编译器“尽可能快地访问这个变量”。加快访问速度取决于现实，但是，正如名字所暗示的那样，这经常是通过在寄存器中放置变量来做到的。这并不能保证将变置在寄存器中，甚至也不能保证提高访问速度。这只是对编译器的一个暗示。

注意：

   使用register变量是有限制的：(1)不可能得到或计算register变量的地址; (2) register变量只能在一个块中声明（不可能有全局的或静态的register变量（c语言里register关键字可以在全局中定义变））。然而可以在一个函数中（即在参数表中）使用register变量作为一个形式参数。

 一般地，不应当推测编译器的优化器，因为它可能比我们做得更好。因此，最好避免使用关键字register。

(4)静态变量

  关键字static有一些独特的意义。通常，函数中定义局部变量在函数中作用域结束时消失。当再次调用这个函数时，会重新创建变量的存储空间，其值会被重新初始化。如果想使局部变量的值在程序的整个生命期里仍然存在，我们可以定义函数的局部变量为static(静态的)，并给它一个初始化。初始化只在函数第一次调用时执行，函数调用之间变量的值保持不变，这种方式，函数可以“记住”函数调用之间的一些信息片断。这也就是所谓的静态局部变量，具有局部作用域，它只被初始化一次，自从第一次被初始化直到程序运行结束都一直存在，它和全局变量的区别在于全局变量对所有的函数都是可见的，而静态局部变量只在定义自己的函数体内始终可见。

  我们可能奇怪为什么不使用全局变量。static局部变量的优点是在函数范围之外它是不可用的，所以它不可能被轻易改变。这会使错误局部化。

  此外同样存在静态全局变量，具有全局作用域，它与全局变量的区别在于如果程序包含多个文件的话，它作用于定义它的文件里，不能作用到其它文件里，即被static关键字修饰过的变量具有文件作用域。这样即使两个不同的源文件都定义了相同名字的静态全局变量，它们也是不同的变量。

(5)外部变量

  extern告诉编译器存在着一个变量和函数，即使编译器在当前的文件中没有看到它。这个变量或函数可能在一个文件或者在当前文件的后面定义。例如extern int i;编译器会知道i肯定作为全局变量存在于某处。当编译器看到变量i的定义时，并没有看到别的声明，所以知道它在文件的前面已经找到了同样声明的i。

(6) const常量

  const告诉编译器这个名字表示常量，不管是内部的还是用户定义的数据类型都可以定义为const。如果定义了某对象为常量，然后试图改变它，编译器将会产生错误。在C++中一个const必须有初始值。

(7) volatile变量

  限定词const告诉编译器“这是不会改变的”(这就是允许编译器执行额外的优化)；而限定词volatile则告诉编译器“不知道何时变化”，防止编译器依据变量的稳定性作任何优化。

## 2.1.20 c++中类型转换机制？各适用什么环境？dynamic_cast转换失败时，会出现什么情况？

 解析：C++中，四个与类型转换相关的关键字：static_cast、const_cast、reinterpret_cast dynamic_cast。

**（1）static_cast**

特点：静态转换，在编译处理期间。

应用场合：主要用于C++中内置的基本数据类型之间的转换，但是没有运行时类型的检测来保证转换的安全性。

 用于基类和子类之间的指针或引用之间的转换，这种转换把子类的指针或引用转换为基类表示是安全的；进行下行转换，把基类的指针或引用转换为子类表示时，由于没有进行动态类型检测，所以是不安全的。上行安全下行不安全

 把void类型的指针转换成目标类型的指针（不安全）。

 不能用于两个不相关的类型转换。

 不能把const对象转换成非const对象。

**（2）const_cast**

特点：去常转换，编译时执行。不是运行时执行

应用场合：const_cast操作不能在不同的种类间转换。相反，它仅仅把它作用的表达式转换成常量。它可以使一个本来不是const类型的数据转换成const类型的，或者把const属性去掉。 

去掉const属性：const_case<int*> (&num)，常用，因为**不能把一个****const****变量直接赋给一个非****const****变量，必须要转换。**



```cpp
int main()
{
    const int constant = 26;
    const int* const_p = &constant;
    int* modifier = const_cast<int*>(const_p);
    *modifier = 3;
    cout<< "constant:  "<<constant<<endl;  //26
    cout<<"*modifier:  "<<*modifier<<endl;   //3
    return 0;
}
```



加上const属性：const int* k = const_case<const int*>(j)，一般很少用，因为可以把一个非const变量直接赋给一个const变量，比如：const int* k = j;

const_case只能转换**指针或引用** 不能转换变量

const int i = 3;

int j = const_cast<int>(i);是不行的

**（3）reinterpret_cast**

特点： 重解释类型转换

应用场合：它有着和c风格强制类型转换同样的功能；它可以转化任何的内置数据类型为其他的类型，同时它也可以把任何类型的指针转化为其他的类型；它的机理是对二进制进行重新的解释，不会改变原来的格式。

**（4）dynamic_cast <**type-id **> ( expression )**

含义：将一个指向基类的指针转换成指向派生类的指针；如果失败，返回空指针。

该运算符将expression转换成type_id类型的对象。type_id必须是类的指针，类的引用或者空类型的指针。

a、如果type_id是一个指针类型，那么expression也必须是一个指针类型，如果type_id是一个引用类型，那么expression也必须是一个引用类型。

b、如果type_id是一个空类型的指针，在运行的时候，就会检测expression的实际类型，结果是一个由expression决定的指针类型。

c、如果type_id不是空类型的指针，在运行的时候指向expression对象的指针能否可以转换成type_id类型的指针。

d、在运行的时候决定真正的类型，如果向下转换是安全的，就返回一个转换后的指针，若不安全，则返回一个空指针。

e、主要用于上下行之间的转换，也可以用于类之间的交叉转换。上行转换时和static_cast效果一样，下行转换时，具有检测功能，比static_cast更安全。



```cpp
class CBasic{
public:
 
    CBasic(){};
    ~CBasic(){};
    virtual void speak() {     //要有virtual才能实现多态，才能使用dynamic cast，如果父类没有虚函数，是编译不过的
        printf("dsdfsd");
    }
private:
 
};
 
//哺乳动物类
class cDerived:public CBasic{
public:
    cDerived(){};
    ~cDerived(){};
private:
};
 
int main()
{
     CBasic  cBasic;
     CDerived  cDerived;
     
     CBasic * pB1 = new CBasic;
     CBasic * pB2 = new CDerived;
     
     //dynamic cast failed, so pD1 is null.  pB1指向对象和括号里的Derived *不一样，转换失败
     CDerived * pD1 = dynamic_cast<CDerived * > (pB1);    
     
     //dynamic cast succeeded, so pD2 points to  CDerived object       
     //dynamic cast 用于将指向子类的父类指针或引用，转换为子类指针或引用 ，pB2指向对象和括号里的Derived *一样，转换成功    
     CDerived * pD2 = dynamic_cast<CDerived * > (pB2);    
     
     //dynamci cast failed, so throw an exception.             
     CDerived & rD1 = dynamic_cast<CDerived &> (*pB1);   
     
     //dynamic cast succeeded, so rD2 references to CDerived object.
     CDerived & rD2 = dynamic_cast<CDerived &> (*pB2);    
     return 0;
}
```
