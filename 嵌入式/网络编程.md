# 3 网络编程

[toc]

## 3.1 TCP UDP

**3.1.1 TCP、UDP的区别 ⭐⭐⭐⭐⭐**

**3.1.2 TCP、UDP的优缺点⭐⭐⭐**

**3.1.3 TCP UDP适用场景⭐⭐⭐**

*3.1.4 TCP为什么是可靠连接⭐⭐⭐⭐*

*3.1.5典型网络模型，简单说说有哪些；⭐⭐⭐*

*3.1.6 Http1.1和Http1.0的区别⭐⭐⭐*

*3.1.7 URI（统一资源标识符）和URL（统一资源定位符）之间的区别⭐⭐*

 

## 3.2 三次握手、四次挥手

*3.2.1什么是三次握手⭐⭐⭐⭐⭐*

*3.2.2为什么三次握手中客户端还要发送一次确认呢？可以二次握手吗？⭐⭐⭐⭐*

*3.2.3为什么服务端易受到SYN攻击？⭐⭐⭐⭐*

*3.2.4什么是四次挥手⭐⭐⭐⭐⭐*

*3.2.5为什么客户端最后还要等待2MSL？⭐⭐⭐⭐*

*3.2.6为什么建立连接是三次握手，关闭连接确是四次挥手呢？⭐⭐⭐⭐*

##  3.1.1 TCP、UDP的区别

解析：TCP---传输控制协议,提供的是面向连接、可靠的字节流服务。当客户和服务器彼此交换数据前，必须先在双方之间建立一个TCP连接，之后才能传输数据。

UDP---用户数据报协议，是一个简单的面向数据报的运输层协议。UDP不提供可靠性，它只是把应用程序传给IP层的数据报发送出去，但是并不能保证它们能到达目的地。

总结为以下几点：

 1）TCP是面向连接的，UDP是面向无连接的

 2）UDP程序结构较简单

 3）TCP是面向字节流的，UDP是基于数据报的

 4）TCP保证数据正确性，UDP可能丢包

 5）TCP保证数据顺序，UDP不保证

 

## 3.1.2 TCP、UDP的优缺点

TCP优点：可靠稳定

   TCP的可靠体现在TCP在传输数据之前，会有三次握手来建立连接，而且在数据传递时，有确认.窗口.重传.拥塞控制机制，在数据传完之后，还会断开来连接用来节约系统资源。

TCP缺点：慢，效率低，占用系统资源高，易被攻击

  在传递数据之前要先建立连接，这会消耗时间，而且在数据传递时，确认机制.重传机制.拥塞机制等都会消耗大量时间，而且要在每台设备上维护所有的传输连接。然而，每个连接都会占用系统的CPU，内存等硬件资源。因为TCP有确认机制.三次握手机制，这些也导致TCP容易被利用，实现DOS. DDOS. CC等攻击。

 

UDP优点：快，比TCP稍安全

   UDP没有TCP拥有的各种机制，是一种无状态的传输协议，所以传输数据非常快，没有TCP的这些机制，被攻击利用的机会就少一些，但是也无法避免被攻击。

UDP缺点：不可靠，不稳定

  因为没有TCP的这些机制，UDP在传输数据时，如果网络质量不好，就会很容易丢包，造成数据的缺失。

 

## 3.1.3 TCP UDP适用场景

TCP：当对网络质量有要求时，比如HTTP，HTTPS，FTP等传输文件的协议；POP，SMTP等邮件传输的协议

UDP：对网络通讯质量要求不高时，要求网络通讯速度要快的场景

**问：****TCP改进：（这个随便说说就行了）**

答：许多调整的参数可用于增强TCP的性能，包括数据段、定时器和窗口的大小。TCP实现中含有大量拥塞避免算法，如俊启动、选择重传和选择确认，它通常能改进像Internet这样的共享网络的性能。但在许多拥塞控制算法，特别是慢启动中，当中等数量数据正在一个具有较大带宽延迟特性的链路上传输时，会产生端到端通信的低效带宽利用问题。对此需要有相应的解决办法。

## 3.1.4 TCP为什么是可靠连接

答：因为tcp传输的数据满足3大条件，不丢失，不重复，按顺序到达，

TCP协议保证数据传输可靠性的方式主要有：

-   校验和
-   序列号
-   确认应答
-   超时重传
-   连接管理
-   流量控制
-   拥塞控制



 csdn有个文章《网络基础：TCP协议-如何保证传输可靠性》写得简单易懂。

## 3.1.5典型网络模型，简单说说有哪些；

看看以下的图即可，四层和七层的比较常见。

 ![img](网络编程.assets/545613072_1590757300047_D1333ACC9771B37DB87F187852C7B9FE)

## 3.1.6 Http1.1和Http1.0的区别

答：

  在http1.0中，当建立连接后，客户端发送一个请求，服务器端返回一个信息后就关闭连接，当浏览器下次请求的时候又要建立连接，显然这种不断建立连接的方式，会造成很多问题。

  在http1.1中，引入了持续连接的概念，通过这种连接，浏览器可以建立一个连接之后，发送请求并得到返回信息，然后继续发送请求再次等到返回信息，也就是说客户端可以连续发送多个请求，而不用等待每一个响应的到来。

  其他的可以自行百度”“HTTP常见面试题 ”。嵌入式稍作了解即可。

## 3.1.7 URI（统一资源标识符）和URL（统一资源定位符）之间的区别

解析：

你可能觉得URI和URL可能是相同的概念，其实并不是，URI和URL都定义了资源是什么，但URL还定义了该如何访问资源。URL是一种具体的

URI，它是URI的一个子集，它不仅唯一标识资源，而且还提供了定位该资源的信息。URI是一种语义上的抽象概念，可以是绝对的，也可以是相对的，而URL则必须提供足够的信息来定位，是绝对的。

## 3.2.1什么是三次握手⭐⭐⭐⭐⭐

解析：第一次握手客户跟服务器说要创建链接，第二次，服务器同意客户端的链接，然后要再和客户端确认一遍是不是真要链接，第三次客户端说真要链接，这才链接。如下图：

 ![img](网络编程.assets/545613072_1590812509163_48798565974D795668A42418F050DBC7)

**上图需要会画出来，很可能要你现场画哦！！**

最初两端的TCP进程都处于CLOSED关闭状态，A主动打开连接，而B被动打开连接。B的TCP服务器进程先创建传输控制块TCB，准备接受客户进程的连接请求。然后服务器进程就处于LISTEN（收听）状态，等待客户的连接请求。若有，则作出响应。

**第一次握手**：起初两端都处于CLOSED关闭状态，**：**A的TCP客户进程也是首先创建传输控制块TCB，然后向B发出连接请求报文段，Client将标志位SYN置为1，随机产生一个值seq=x，并将该数据包发送给Server，Client进入SYN-SENT状态，等待Server确认；

**第二次握手**：Server收到数据包后由标志位SYN=1得知Client请求建立连接，Server将标志位SYN和ACK都置为1，ack=x+1，随机产生一个值seq=y，并将该数据包发送给Client以确认连接请求，Server进入SYN-RCVD状态，此时操作系统为该TCP连接分配TCP缓存和变量；

**第三次握手**：Client收到确认后，检查ack是否为x+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=y+1，并且此时操作系统为该TCP连接分配TCP缓存和变量，并将该数据包发送给Server，Server检查ack是否为y+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client和Server就可以开始传输数据。

 

**注意**：Server第二次握手将ACK置一，且进行资源分配

​      Client第三次握手将ACK置一，且进行资源分配

## 3.2.2为什么三次握手中客户端还要发送一次确认呢？可以二次握手吗？

答：**主要为了防止已失效的连接请求报文段突然又传送到了B，因而产生错误**。如A发出连接请求，但因连接请求报文丢失而未收到确认，于是A再重传一次连接请求。后来收到了确认，建立了连接。数据传输完毕后，就释放了连接，A工发出了两个连接请求报文段，其中第一个丢失，第二个到达了B，但是第一个丢失的报文段只是在**某些网络结点长时间滞留了，延误到连接释放以后的某个时间才到达B**，此时B误认为A又发出一次新的连接请求，于是就向A发出确认报文段，同意建立连接，不采用三次握手，只要B发出确认，就建立新的连接了，此时A不理睬B的确认且不发送数据，则B一致等待A发送数据，浪费资源。

 

网上看到的其他答案：C是Client，S是Server。

答：现在把三次握手改成仅需要两次握手，死锁是可能发生的。作为例子，考虑计算机S和C之间的通信，假定C给S发送一个连接请求分组，S收到了这个分组，并发 送了确认应答分组。按照两次握手的协定，S认为连接已经成功地建立了，可以开始发送数据分组。可是，C在S的应答分组在传输中被丢失的情况下，将不知道S是否已准备好，不知道S建立什么样的序列号，C甚至怀疑S是否收到自己的连接请求分组。在这种情况下，C认为连接还未建立成功，将忽略S发来的任何数据分 组，只等待连接确认应答分组。而S在发出的分组超时后，重复发送同样的分组。这样就形成了死锁。

## 3.2.3为什么服务端易受到SYN攻击？

答：服务器端的资源分配是在二次握手时分配的，而客户端的资源是在完成三次握手时分配的，所以服务器容易受到SYN洪泛攻击，SYN攻击就是Client在短时间内伪造大量不存在的IP地址，并向Server不断地发送SYN包，Server则回复确认包，并等待Client确认，由于源地址不存在，因此Server需要不断重发直至超时，这些伪造的SYN包将长时间占用未连接队列，导致正常的SYN请求因为队列满而被丢弃，从而引起网络拥塞甚至系统瘫痪。

防范SYN攻击措施：降低主机的等待时间使主机尽快的释放半连接的占用，短时间受到某IP的重复SYN则丢弃后续请求。

## 3.2.4什么是四次挥手

解析：

 ![img](网络编程.assets/545613072_1590812715420_B8ABB0C7B81DF5E331CAD0129CFE6C6C)

1客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1）吧要消耗一个序号。

2服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。

3客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。

4服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。

5客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2∗ ∗*MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。

6服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。

 

## 3.2.5为什么客户端最后还要等待2MSL？

解析：MSL（Maximum Segment Lifetime），TCP允许不同的实现可以设置不同的MSL值。

 第一，保证客户端发送的最后一个ACK报文能够到达服务器，因为这个ACK报文可能丢失，站在服务器的角度看来，我已经发送了FIN+ACK报文请求断开了，客户端还没有给我回应，应该是我发送的请求断开报文它没有收到，于是服务器又会重新发送一次，而客户端就能在这个2MSL时间段内收到这个重传的报文，接着给出回应报文，并且会重启2MSL计时器。

 第二，防止类似与“三次握手”中提到了的“已经失效的连接请求报文段”出现在本连接中。客户端发送完最后一个确认报文后，在这个2MSL时间中，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样新的连接中不会出现旧连接的请求报文。

 

## 3.2.6为什么建立连接是三次握手，关闭连接确是四次挥手呢？ 

  解析：建立连接的时候，服务器在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。

  而关闭连接时，服务器收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送，从而导致多了一次。